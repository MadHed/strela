// Copyright (c) 2018 Stephan Unverwerth
// This code is licensed under MIT license (See LICENSE for details)

module Std.Lang.Compiler.Lexer {
    import Std.IO.File;
    import Std.Collections.Map;

    export enum TokenType {
        Eof,
        Module,
        Import,
        Export,
        Require,
        Entry,
        Class,
        Interface,
        Enum,
        Function,
        Var,
        If,
        Else,
        While,
        Return,
        New,
        This,
        Identifier,
        StringLiteral,
        IntLiteral,
        FloatLiteral,
        ParenOpen,
        ParenClose,
        BracketOpen,
        BracketClose,
        CurlyOpen,
        CurlyClose,
        ExclamationMark,
        QuestionMark,
        Period,
        Comma,
        Colon,
        Semicolon,
        Whitespace,
        Comment,
        Asterisk,
        Equals,
        EqualsEquals,
        ExclEquals,
        Amp,
        AmpAmp,
        Pipe,
        PipePipe,
        Slash,
        Plus,
        PlusPlus,
        Minus,
        MinusMinus,
        Percent,
        LessThan,
        GreaterThan,
        LessThanEquals,
        GreaterThanEquals,
        Invalid,
        Missing
    }

    export class Token {
        var type: TokenType;
        var value: String;
        var file: File;
        var row: u32;
        var column: u32;

        function init(file: File, tt: TokenType, val: String) {
            this.file = file;
            type = tt;
            value = val;
        }
    }

    function isWs(ch: String): bool {
        return ch == " " || ch == "\t" || ch == "\r" || ch == "\n";
    }

    function isNum(ch: String): bool {
        return
            ch == "0" ||
            ch == "1" ||
            ch == "2" ||
            ch == "3" ||
            ch == "4" ||
            ch == "5" ||
            ch == "6" ||
            ch == "7" ||
            ch == "8" ||
            ch == "9";
    }

    function isAl(ch: String): bool {
        return ch == "a" || ch == "b" || ch == "c" || ch == "d" || ch == "e" || ch == "f" || ch == "g" || ch == "h" || ch == "i" || ch == "j" || ch == "k" || ch == "l" || ch == "m" || ch == "n" || ch == "o" || ch == "p" || ch == "q" || ch == "r" || ch == "s" || ch == "t" || ch == "u" || ch == "v" || ch == "w" || ch == "x" || ch == "y" || ch == "z" ||
        ch == "A" || ch == "B" || ch == "C" || ch == "D" || ch == "E" || ch == "F" || ch == "G" || ch == "H" || ch == "I" || ch == "J" || ch == "K" || ch == "L" || ch == "M" || ch == "N" || ch == "O" || ch == "P" || ch == "Q" || ch == "R" || ch == "S" || ch == "T" || ch == "U" || ch == "V" || ch == "W" || ch == "X" || ch == "Y" || ch == "Z";
    }

    function isAlNum(ch: String): bool {
        return isAl(ch) || isNum(ch);
    }

    export class Lexer {
        function init(f: File) {
            file = f;
            ch = file.getc();
            str = new String();

            singleChars = new Map<String, TokenType>;
            singleChars.set("+", TokenType.Plus);
            singleChars.set("-", TokenType.Minus);
            singleChars.set("*", TokenType.Asterisk);
            singleChars.set("/", TokenType.Slash);
            singleChars.set("(", TokenType.ParenOpen);
            singleChars.set(")", TokenType.ParenClose);
            singleChars.set("<", TokenType.LessThan);
            singleChars.set(">", TokenType.GreaterThan);
            singleChars.set("{", TokenType.CurlyOpen);
            singleChars.set("}", TokenType.CurlyClose);
            singleChars.set("[", TokenType.BracketOpen);
            singleChars.set("]", TokenType.BracketClose);
            singleChars.set(",", TokenType.Comma);
            singleChars.set(";", TokenType.Semicolon);
            singleChars.set(".", TokenType.Period);
        }

        function hasNext(): bool {
            return !file.isEof();
        }

        function next(): Token {
            str = "";
            if (isWs(ch)) {
                return whitespace();
            }
            else if (ch == "\"") {
                return string();
            }
            else if (ch == "/") {
                if (file.peek() == "/") {
                    return lineComment();
                }
                else if (file.peek() == "*") {
                    return blockComment();
                }
                else {
                    ch = file.getc();
                    return new Token(file, TokenType.Slash, str);
                }
            }
            else if (isAl(ch) || ch == "_") {
                return idOrKeyword();
            }
            else if (isNum(ch)) {
                return number();
            }
            else if (ch == "<") {
                ch = file.getc();
                if (ch == "=") {
                    ch = file.getc();
                    return new Token(file, TokenType.LessThanEquals, "<=");
                }
                else {
                    return new Token(file, TokenType.LessThan, "<");
                }
            }
            else if (ch == ">") {
                ch = file.getc();
                if (ch == "=") {
                    ch = file.getc();
                    return new Token(file, TokenType.GreaterThanEquals, ">=");
                }
                else {
                    return new Token(file, TokenType.GreaterThan, ">");
                }
            }
            else if (ch == "=") {
                ch = file.getc();
                if (ch == "=") {
                    ch = file.getc();
                    return new Token(file, TokenType.EqualsEquals, "==");
                }
                else {
                    return new Token(file, TokenType.Equals, "=");
                }
            }
            else if (ch == "+") {
                ch = file.getc();
                if (ch == "+") {
                    ch = file.getc();
                    return new Token(file, TokenType.PlusPlus, "++");
                }
                else {
                    return new Token(file, TokenType.Plus, "+");
                }
            }
            else if (ch == "-") {
                ch = file.getc();
                if (ch == "-") {
                    ch = file.getc();
                    return new Token(file, TokenType.MinusMinus, "--");
                }
                else {
                    return new Token(file, TokenType.Minus, "-");
                }
            }
            else if (ch == "&") {
                ch = file.getc();
                if (ch == "&") {
                    ch = file.getc();
                    return new Token(file, TokenType.AmpAmp, "&&");
                }
                else {
                    return new Token(file, TokenType.Amp, "&");
                }
            }
            else if (ch == "|") {
                ch = file.getc();
                if (ch == "|") {
                    ch = file.getc();
                    return new Token(file, TokenType.PipePipe, "||");
                }
                else {
                    return new Token(file, TokenType.Pipe, "|");
                }
            }
            else if (ch == "!") {
                ch = file.getc();
                if (ch == "=") {
                    ch = file.getc();
                    return new Token(file, TokenType.ExclEquals, "!=");
                }
                else {
                    return new Token(file, TokenType.ExclamationMark, "!");
                }
            }
            else if (ch == "(") { var old = ch; ch = file.getc(); return new Token(file, TokenType.ParenOpen, old); }
            else if (ch == ")") { var old = ch; ch = file.getc(); return new Token(file, TokenType.ParenClose, old); }
            else if (ch == "[") { var old = ch; ch = file.getc(); return new Token(file, TokenType.BracketOpen, old); }
            else if (ch == "]") { var old = ch; ch = file.getc(); return new Token(file, TokenType.BracketClose, old); }
            else if (ch == "{") { var old = ch; ch = file.getc(); return new Token(file, TokenType.CurlyOpen, old); }
            else if (ch == "}") { var old = ch; ch = file.getc(); return new Token(file, TokenType.CurlyClose, old); }
            else if (ch == ".") { var old = ch; ch = file.getc(); return new Token(file, TokenType.Period, old); }
            else if (ch == ",") { var old = ch; ch = file.getc(); return new Token(file, TokenType.Comma, old); }
            else if (ch == ":") { var old = ch; ch = file.getc(); return new Token(file, TokenType.Colon, old); }
            else if (ch == ";") { var old = ch; ch = file.getc(); return new Token(file, TokenType.Semicolon, old); }
            else if (ch == "?") { var old = ch; ch = file.getc(); return new Token(file, TokenType.QuestionMark, old); }
            else if (ch == "*") { var old = ch; ch = file.getc(); return new Token(file, TokenType.Asterisk, old); }
            else if (ch == "/") { var old = ch; ch = file.getc(); return new Token(file, TokenType.Slash, old); }
            else if (ch == "%") { var old = ch; ch = file.getc(); return new Token(file, TokenType.Percent, old); }
            else {
                if (singleChars.has(ch)) {
                    var type = singleChars[ch];
                    var old = ch;
                    ch = file.getc();
                    return new Token(file, type, old);
                }
                else {
                    var old = ch;
                    ch = file.getc();
                    return new Token(file, TokenType.Invalid, old);
                }
            }
        }

        function string(): Token {
            str += "\"";
            ch = file.getc();
            var escaped = false;
            while(!(ch == "\"" && !escaped)) {
                str += ch;
                escaped = ch == "\\" && !escaped;
                ch = file.getc();
            }
            str += "\"";
            ch = file.getc();
            return new Token(file, TokenType.StringLiteral, str);
        }

        function lineComment(): Token {
            ch = file.getc(); // "/"
            ch = file.getc(); // first char of comment
            str = "//";
            while (!(ch == "\r" || ch == "\n") && !file.isEof()) {
                str += ch;
                ch = file.getc();                
            }
            return new Token(file, TokenType.Comment, str);
        }

        function blockComment(): Token {
            ch = file.getc(); // "*"
            ch = file.getc(); // first char of comment
            str = "/*";
            while (!(ch == "*" && file.peek() == "/") && !file.isEof()) {
                str += ch;
                ch = file.getc();                
            }
            file.getc();
            ch = file.getc();
            str += "*/";
            return new Token(file, TokenType.Comment, str);
        }

        function number(): Token {
            str += ch;
            ch = file.getc();
            while(isNum(ch)) {
                str += ch;
                ch = file.getc();
            }

            if (ch == ".") {
                str += ".";
                ch = file.getc();
                while(isNum(ch)) {
                    str += ch;
                    ch = file.getc();
                }
                return new Token(file, TokenType.FloatLiteral, str);
            }
            return new Token(file, TokenType.IntLiteral, str);
        }

        function whitespace(): Token {
            while(isWs(ch)) {
                str += ch;
                ch = file.getc();
            }
            return new Token(file, TokenType.Whitespace, str);
        }

        function idOrKeyword(): Token {
            str += ch;
            ch = file.getc();
            while((isAlNum(ch) || ch == "_")) {
                str += ch;
                ch = file.getc();
            }

            if (str == "module") return new Token(file, TokenType.Module, str);
            else if (str == "import") return new Token(file, TokenType.Import, str);
            else if (str == "export") return new Token(file, TokenType.Export, str);
            else if (str == "entry") return new Token(file, TokenType.Entry, str);
            else if (str == "require") return new Token(file, TokenType.Require, str);
            else if (str == "class") return new Token(file, TokenType.Class, str);
            else if (str == "interface") return new Token(file, TokenType.Interface, str);
            else if (str == "enum") return new Token(file, TokenType.Enum, str);
            else if (str == "function") return new Token(file, TokenType.Function, str);
            else if (str == "var") return new Token(file, TokenType.Var, str);
            else if (str == "if") return new Token(file, TokenType.If, str);
            else if (str == "else") return new Token(file, TokenType.Else, str);
            else if (str == "while") return new Token(file, TokenType.While, str);
            else if (str == "return") return new Token(file, TokenType.Return, str);
            else if (str == "new") return new Token(file, TokenType.New, str);
            else if (str == "this") return new Token(file, TokenType.This, str);
            else return new Token(file, TokenType.Identifier, str);
        }

        var str: String;
        var ch: String;
        var file: File;

        var singleChars: Map<String, TokenType>;
    }
}