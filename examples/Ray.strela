// Copyright (c) 2018 Stephan Unverwerth
// This code is licensed under MIT license (See LICENSE for details)

module Examples.Ray {
    import Std.IO.*;
    import Std.Collections.List;
    import Std.Math.Lina.*;

    class TGA {
        var file: File;
        
        function init(name: String, width: int, height: int) {
            this.file = new File(name, "wb");
            this.file.write(0: u8); // no id
            this.file.write(0: u8); // no palette
            this.file.write(2: u8); // 24 bit rgb
            this.file.write(0: u16); // palette begin
            this.file.write(0: u16); // palette length
            this.file.write(0: u8); // palette entry size
            this.file.write(0: u16); // x begin
            this.file.write(0: u16); // y begin
            this.file.write(width: u16); // width
            this.file.write(height: u16); // height
            this.file.write(24: u8); // bpp
            this.file.write(32: u8); // attrib bits (32 = top to bottom)
        }

        function pixel(color: Vec) {
            var r: u8 = 0;
            var g: u8 = 0;
            var b: u8 = 0;

            if (color.x > 1) r = 255;
            else if (color.x < 0) r = 0;
            else r = color.x * 255;

            if (color.y > 1) g = 255;
            else if (color.y < 0) g = 0;
            else g = color.y * 255;

            if (color.z > 1) b = 255;
            else if (color.z < 0) b = 0;
            else b = color.z * 255;

            this.file.write(b);
            this.file.write(g);
            this.file.write(r);
        }
    }

    external function sqrt(f: f64): f64;
    external function rand(): i32;
    external function sin(r: f64): f64;
    external function cos(r: f64): f64;

    function frand(): f64 {
        return (rand():f64 / 2147483647:f64) - 0.5;
        //return (rand():f64 / 65535:f64) - 0.5;
    }

    function clamp(f: f64): f64 {
        if (f > 1.0) return 1.0;
        if (f < 0.0) return 0.0;
        return f;
    }

    function lerp(a: Vec, b: Vec, f: f64): Vec {
        return a * (1.0 - f) + b * f;
    }

    class Plane {
        var position: Vec;
        var normal: Vec;

        function init(position: Vec, normal: Vec) {
            this.position = position;
            this.normal = normal;
        }
    }

    class Sphere {
        var center: Vec;
        var radius: f64;
        var color: Vec;
        var reflectivity: f64;

        function init(center: Vec, radius: f64, color: Vec, reflectivity: f64) {
            this.center = center;
            this.radius = radius;
            this.color = color;
            this.reflectivity = reflectivity;
        }
    }

    class Hit {
        var position: Vec;
        var normal: Vec;
        var color: Vec;
        var reflectivity: f64;
        var roughness: f64;
    }

    class Tracer {
        var spheres: List<Sphere>;
        var planes: List<Plane>;
        var file: TGA;
        var width: int;
        var height: int;

        function init() {
            this.planes = new List<Plane>();
            this.planes.append(new Plane(new Vec(-20, 0, 20), (new Vec(1, 0, -1)).normalized() ));

            this.spheres = new List<Sphere>();
            this.spheres.append(new Sphere(new Vec(5, 5, 5), 5, new Vec(0, 0, 0), 0.7));
            this.spheres.append(new Sphere(new Vec(5, -5, 10), 5, new Vec(1, 0, 0), 0.8));
            this.spheres.append(new Sphere(new Vec(-5, 5, 15), 5, new Vec(0, 1, 0), 0.5));
            this.spheres.append(new Sphere(new Vec(-5, -5, 20), 5, new Vec(0, 0, 1), 0.25));

            this.width = 320;
            this.height = 200;
            this.file = new TGA("out.tga", this.width, this.height);
        }

        function trace(origin: Vec, dir: Vec, recurse: int): Vec {
            var found = false;
            var min: f64 = 999999.0;
            var hit = new Hit;

            var i = 0;
            while (i < this.spheres.length) {
                var sphere = this.spheres[i];

                var oc = origin - sphere.center;

                var a = dir.dot(oc);
                a = a * a;
                a = a - oc.dot(oc);
                a = a + (sphere.radius * sphere.radius);

                if (a > 0.0) {
                    var d = -dir.dot(oc) - sqrt(a);

                    if (d > 0.0 && (!found || d < min)) {
                        min = d;
                        found = true;

                        hit.position = origin + dir * d;
                        hit.normal = (hit.position - sphere.center).normalized();
                        hit.color = sphere.color;
                        hit.reflectivity = sphere.reflectivity;
                        hit.roughness = 0.125;
                    }
                }

                i++;
            }

            i = 0;
            while (i < this.planes.length) {
                var plane = this.planes[i];

                var d = (plane.position - origin).dot(plane.normal) / dir.dot(plane.normal);

                if (d > 0.0 && (!found || d < min)) {
                    min = d;
                    found = true;

                    hit.position = origin + dir * d;
                    hit.normal = plane.normal;
                    hit.color = new Vec(0,0,0);
                    hit.reflectivity = 0.5;
                    hit.roughness = 0.125;
                }

                i++;
            }

            if (found) {
                if (recurse < 5) {
                    var n2 = hit.normal + new Vec(frand()*hit.roughness, frand()*hit.roughness, frand()*hit.roughness);
                    n2.normalize();
                    var r = reflect(dir, n2);
                    return lerp(hit.color * clamp(n2.y), this.trace(hit.position + r * 0.001, r, recurse + 1), hit.reflectivity);
                }
                else {
                    return hit.color * clamp(hit.normal.y);
                }
            }

            if (dir.y < 0) {
                var v = dir.y * 0.4;
                return new Vec(0.4 + v, 0.3 + v, 0.1);
            }
            else {
                var v = dir.y * 0.6;
                return new Vec(0.4 + v, 0.4 + v, 1);
            }
        }

        function run() {
            var x: u32 = 0;
            var y: u32 = 0;
            var dir = new Vec;
            var origin = new Vec(0, 0, 0);

            while (y < this.height) {
                while (x < this.width) {
                    var color = new Vec(0, 0, 0);
                    
                    var num: i32 = 0;

                    var ix = -3;
                    var iy = -3;
                    while (iy < -2) {
                        while (ix < -2) {
                            dir.x = (x:f64+ix:f64*0.14):f64 - (this.width:f64 * 0.5);
                            dir.y = -((y:f64+iy:f64*0.14):f64 - (this.height:f64 * 0.5));
                            dir.z = this.width:f64 * 0.3;
                            dir.normalize();
                            color = color + this.trace(origin, dir, 0);
                            num++;
                            ix++;
                        }
                        ix = -1;
                        iy++;
                    }

                    this.file.pixel(color * (1.0 / num:f64));
                    x++;
                }
                x = 0;
                y++;
                println(y);
            }

            println("Fin");
        }
    }

    function main(args: String[]): int {
        var tracer = new Tracer;
        tracer.run();

        return 0;
    }
}